#include "dual-defines.inc"

ometa WinxedParser <: Parser {
  fromTo :x :y = seq(x) (~seq(y) char)* seq(y), 
  space        = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
  nameFirst    = letter | '_',
  nameRest     = nameFirst | digit,
  iName        = firstAndRest(#nameFirst, #nameRest):r                               -> r.join(''),
  isKeyword :x = ?SELF._isKeyword(x),
  keyword      = iName:k isKeyword(k)                                                -> [k, k],
  nameTok      = iName:n                                                             -> [#name, n],
  hexDigit     = char:x {SELF['hexDigits'].indexOf(x.toLowerCase())}:v ?(v >= 0)     -> v,
  hexLit       = hexLit:n hexDigit:d                                                 -> (n * 16 + d)
               | hexDigit,
  number       = ``0x'' hexLit:n                                                     -> [#number, n]
               | digit+:ws ('.' digit+ | empty -> []):fs                             -> [#number, parseFloat(ws.join('') + '.' +
                                                                                                             fs.join(''))],
  escapeChar   = '\\' char:c                                                         -> unescape('\\' + c),
  str          = seq('"""')  (escapeChar | ~seq('"""') char)*:cs seq('"""')          -> [#str, cs.join('')]
               | '\'' (escapeChar | ~'\'' char)*:cs '\''                             -> [#str, cs.join('')]
               | '"'  (escapeChar | ~'"'  char)*:cs '"'                              -> [#str, cs.join('')]
               | ('#' | '`') iName:n                                                 -> [#str, n],
  special      = ( '('   | ')'    | '{'    | '}'     | '['    | ']'     | ','    
                 | ';'   | '?'    | ':'    | ``!=='' | ``!='' | ``==='' | ``==''
                 | ``='' | ``>='' | '>'    | ``<=''  | '<'    | ``++''  | ``+=''
                 | '+'   | ``--'' | ``-='' | '-'     | ``*='' | '*'     | ``/=''
                 | '/'   | ``%='' | '%'    | ``&&='' | ``&&'' | ``||='' | ``||''
                 | '.'   | '!'                                                   ):s -> [s, s],
  tok          = spaces (keyword | nameTok | number | str | special),
  toks         = token*:ts spaces end                                                -> ts,
  token :tt    = tok:t ?(t[0] == tt)                                                 -> t[1],

  name         = spaces nameTok:t                                                    -> t[1],

  expr         = orExpr:e ( "?"   expr:t   ":" expr:f                                -> [#condExpr, e, t, f]
                          | "="   expr:rhs                                           -> [#set,  e, rhs]
                          | "+="  expr:rhs                                           -> [#mset, e, "+",  rhs]
                          | "-="  expr:rhs                                           -> [#mset, e, "-",  rhs]
                          | "*="  expr:rhs                                           -> [#mset, e, "*",  rhs]
                          | "/="  expr:rhs                                           -> [#mset, e, "/",  rhs]
                          | "%="  expr:rhs                                           -> [#mset, e, "%",  rhs]
                          | "&&=" expr:rhs                                           -> [#mset, e, "&&", rhs]
                          | "||=" expr:rhs                                           -> [#mset, e, "||", rhs]
                          | empty                                                    -> e
                          ),
  orExpr       = orExpr:x "||" andExpr:y                                             -> [#binop, "||", x, y]
               | andExpr,
  andExpr      = andExpr:x "&&" eqExpr:y                                             -> [#binop, "&&", x, y]
               | eqExpr,
  eqExpr       = eqExpr:x ( "=="  relExpr:y                                          -> [#binop, "==",  x, y]
                          | "!="  relExpr:y                                          -> [#binop, "!=",  x, y]
                          | "===" relExpr:y                                          -> [#binop, "===", x, y]
                          | "!==" relExpr:y                                          -> [#binop, "!==", x, y]
                          )
               | relExpr,
  relExpr      = relExpr:x ( ">"          addExpr:y                                  -> [#binop, ">",          x, y]
                           | ">="         addExpr:y                                  -> [#binop, ">=",         x, y]
                           | "<"          addExpr:y                                  -> [#binop, "<",          x, y]
                           | "<="         addExpr:y                                  -> [#binop, "<=",         x, y]
                           | "instanceof" addExpr:y                                  -> [#binop, "instanceof", x, y]
                           )
               | addExpr,
  addExpr      = addExpr:x "+" mulExpr:y                                             -> [#binop, "+",          x, y]
               | addExpr:x "-" mulExpr:y                                             -> [#binop, "-",          x, y]
               | mulExpr,
  mulExpr      = mulExpr:x "*" unary:y                                               -> [#binop, "*",          x, y]
               | mulExpr:x "/" unary:y                                               -> [#binop, "/",          x, y]
               | mulExpr:x "%" unary:y                                               -> [#binop, "%",          x, y]
               | unary,
  unary        = "-"      postfix:p                                                  -> [#unop,  "-",        p]
               | "+"      postfix:p                                                  -> [#unop,  "+",        p]
               | "++"     postfix:p                                                  -> [#preop, "++",       p]
               | "--"     postfix:p                                                  -> [#preop, "--",       p]
               | "!"      unary:p                                                    -> [#unop,  "!",        p]
               | postfix,
  postfix      = primExpr:p ( "++"                                                   -> [#postop, "++", p]
                            | "--"                                                   -> [#postop, "--", p]
                            | empty                                                  -> p
                            ),
  primExpr     = primExpr:p ( "[" expr:i "]"                                         -> [#getp, i, p]
                            | "." name:m "(" listOf(#expr, ','):as ")"               -> [#send, m, p].concat(as)
                            | "." name:f                                             -> [#geta, [#get, f], p]
                            | "(" listOf(#expr, ','):as ")"                          -> [#call, p].concat(as)
                            )
               | primExprHd,
  primExprHd   = "(" expr:e ")"                                                      -> e
               | "self"                                                              -> [#self]
               | "number":n                                                          -> [#number, n]
               | "str":s                                                             -> [#string, s]
               | anonFunc
               | "new" name:n "(" ( expr | empty -> UNDEF ):e ")"                    -> [#new, n, e]
               | "new" name:n                                                        -> [#new, n, UNDEF]
               | "[" listOf(#expr, ','):es "]"                                       -> [#arr].concat(es)
               | json
               | name:n                                                              -> [#get, n],
  json         = "{" listOf(#jsonBinding, ','):bs "}"                                -> [#json].concat(bs),
  jsonBinding  = jsonPropName:n ":" expr:v                                           -> [#binding, n, v],
  jsonPropName = "number" | "str" | name,
  formal       = var:v -> v.join(' ')
               | name,
  anonFunc     = "function" funcRest:f                                               -> [#anonfunc].concat(f),
  funcRest     = "(" listOf(#formal, ','):fs ")" "{" srcElems:ss "}"                 -> [fs, ss],
  sc           = ";",
  block        = "{" srcElems:ss "}"                                                 -> ss,
  var          = ("var"|"string"|"int"|"num"):t name:n                               -> [t, n],
  varInit      = var:v ( "=" expr
                       | empty -> [#get, 'null'] ):i                                 -> [#varinit].concat(v).concat([i]),
  varNoInit    = var:v                                                               -> [#var].concat(v),
  stmt         = block
               | varInit:r sc                                                        -> r
               | "if" "(" expr:c ")" stmt:t ( "else" stmt
                                            | empty -> [#get, ''] ):f                -> [#if, c, t, f]
               | "while" "(" expr:c ")" stmt:s                                       -> [#while,   c, s]
               | "do" stmt:s "while" "(" expr:c ")" sc                               -> [#doWhile, s, c]
               | "for" "(" ( varInit
                           | expr
                           | empty -> [#get, 'null'] ):i
                       ";" ( expr
                           | empty -> [#get, 'true']      ):c
                       ";" ( expr
                           | empty -> [#get, 'null'] ):u
                       ")" stmt:s                                                    -> [#for, i, c, u, s]
               | "for" "(" ( varNoInit
                           | expr                                             ):v
                      "in" expr:e
                       ")" stmt:s                                                    -> [#forIn, v, e, s]
               | "switch" "(" expr:e ")" "{"
                   ( "case" expr:c ":" srcElems:cs -> [#case, c, cs]
                   | "default"     ":" srcElems:cs -> [#default, cs] )*:cs
                 "}"                                                                 -> [#switch, e].concat(cs)
               | "break" sc                                                          -> [#break]
               | "continue" sc                                                       -> [#continue]
               | "throw" expr:e sc                                                   -> [#throw, e]
               | "try" block:t "catch" "(" name:e ")" block:c                        -> [#try, t, e, c]
               | "return" ( expr
                          | empty -> [#get, UNDEF] ):e sc                            -> [#return, e]
               | expr:e sc                                                           -> e
               | "using" "static":t name:n               sc                          -> [#using, n, t]
               | "using" "extern":t listOf(#name, '.'):fqn sc                        -> [#using, fqn.join('.'), t]
               | "using"            listOf(#name, '.'):fqn sc                        -> [#using, fqn.join('.'), UNDEF]
               | ";"                                                                 -> [#get, "null"],
  classRest    = "{" classElem*:es "}"                                               -> [#begin].concat(es),
  classBases   = ":" listOf(#name, ","):bs                                           -> bs,
  classBases   = empty                                                               -> [],
  classVar     = var:v ?(v[0] == 'var') sc                                           -> [#var].concat(v),
  classElem    = funcDecl
               | classVar,

  flag         = name:n ( "(" expr:arg ")" -> arg
                        | empty            -> UNDEF
                        ):b                                                          -> [#flag, n, b],
  flagsList    = "[" listOf(#flag, ','):fs "]"                                       -> [#flaglist].concat(fs),

  funcDecl     = "function" name:n 
                      ( flagsList
                      | empty       -> UNDEF
                      ):flags        funcRest:f                                      -> [#funcdecl, n, flags].concat(f),
  classDecl    = "class"    name:n classBases:bs classRest:c                         -> [#classdecl, n, bs, c],

  srcElems     = stmt*:ss                                                            -> [#begin].concat(ss),

  topElem      = funcDecl
               | classDecl
               | "ometa" -> [#ometa],
  topLevel     = topElem*:es spaces end                                              -> [#top].concat(es)
}

ometa WinxedSemActionParser <: WinxedParser {
  curlySemAction = "{" expr:r "}" spaces                                     -> r
                 | "{" (stmt:s &(expr | stmt) -> s)*:ss
                       ( expr:r -> [#return, r] | stmt):s {ss.push(s)}
                   "}" spaces                                                -> [#call,
                                                                                      [#anonfunc, ['self'], [#begin].concat(ss)],
                                                                                      [#self]],
  semAction      = curlySemAction
                 | primExpr:r spaces                                         -> r
}

ometa WinxedTranslator {
  trans          = [:t apply(t):ans]                    -> ans,
  curlyTrans     = [#begin curlyTrans:r]                -> r
                 | [#begin blockSemiTrans*:rs]          -> ('{' + rs.join('') + '}')
                 | blockSemiTrans:r                     -> ('{' + r + '}'),
  blockSemiTrans = trans:x ( (?(x[STRLEN(x) - 1] == '}') -> x
                             | empty                    -> (x + ';')
                             )
                           ):r                          -> r,

  self                                                  -> 'self',
  break                                                 -> 'break',
  continue                                              -> 'continue',
  number   :n                                           -> ('(' + n + ')'),
  string   :s                                           -> s.toProgramString(),
  arr      trans*:xs                                    -> ('[' + xs.join(',') + ']'),
  unop     :op trans:x                                  -> ('(' + op + ' ' + x + ')'),
  getp     trans:fd trans:x                             -> (x + '[' + fd + ']'),
  geta     trans:fd trans:x                             -> (x + '.' + fd),
  get      :x                                           -> x,
  set      trans:lhs trans:rhs                          -> ('(' + lhs + '=' + rhs + ')'),
  mset     trans:lhs :op trans:rhs                      -> ('(' + lhs + op + '=' + rhs + ')'),
  binop    :op trans:x trans:y                          -> ('(' + x + ' ' + op + ' ' + y + ')'),
  preop    :op trans:x                                  -> (op + x),
  postop   :op trans:x                                  -> (x + op),
  return   UNDEF                                        -> 'return',
  return   trans:x                                      -> ('return ' + x),
  if       trans:cond curlyTrans:t curlyTrans:e         -> ('if(' + cond + ')' + t + 'else' + e),
  condExpr trans:cond trans:t trans:e                   -> ('(' + cond + '?' + t + ':' + e + ')'),
  while    trans:cond curlyTrans:body                   -> ('while(' + cond + ')' + body),
  doWhile  curlyTrans:body trans:cond                   -> ('do' + body + 'while(' + cond + ')'),
  for      trans:init trans:cond trans:upd
           curlyTrans:body                              -> ('for(' + init + ';' + cond + ';' + upd + ')' + body),
  forIn    trans:x trans:arr curlyTrans:body            -> ('for(' + x + ' in ' + arr + ')' + body),
  using    :name UNDEF                                  -> ('using ' + name),
  using    :name :type                                  -> ('using ' + type + ' ' + name),
  begin    blockSemiTrans*:xs                           -> ('{' + xs.join('') + '}'),
  top      trans*:xs                                    -> xs.join(''),
  flag     :name UNDEF                                  -> name,
  flag     :name :arg                                   -> (name + '(' + arg + ')'),
  flaglist trans*:fs                                    -> fs.join(','),
  anonfunc :args                    curlyTrans:body     -> ('(function (' + args.join(',') + ')' + body + ')'),
  funcdecl  :name UNDEF       :args curlyTrans:body     -> ('function ' + name +                '(' + args.join(',') + ')' + body),
  funcdecl  :name trans:flags :args curlyTrans:body     -> ('function ' + name + '[' + flags + '](' + args.join(',') + ')' + body),
  classdecl :name :bases curlyTrans:body                -> ('class ' + name + (STRLEN(bases) > 0 ? ':' + bases.join(',') : '') + body),

  call     trans:fn trans*:args                         -> (fn + '(' + args.join(',') + ')'),
  send     :msg trans:recv trans*:args                  -> (recv + '.' + msg + '(' + args.join(',') + ')'),
  new      :cls UNDEF                                   -> ('new ' + cls + '()'),
  new      :cls trans:arg                               -> ('new ' + cls + '(' + arg + ')'),
  var      :type :name                                  -> (type + ' ' + name),
  varinit  :type :name trans:init                       -> (type + ' ' + name + ' = ' + init),
  throw    trans:x                                      -> ('throw ' + x),
  try      curlyTrans:x :name curlyTrans:c              -> ('try ' + x + 'catch(' + name + ')' + c),
  json     trans*:props                                 -> ('({' + props.join(',') + '})'),
  binding  :name trans:val                              -> (name.toProgramString() + ': ' + val),
  switch   trans:x trans*:cases                         -> ('switch(' + x + '){' + cases.join(';') + '}'),
  case     trans:x trans:y                              -> ('case ' + x + ': '+ y),
  default          trans:y                              -> ('default: ' + y)
}

// vim: sts=2 sw=2 et ft=javascript :
